class Play {

  Cat cat;
  Button pauseBtn;
  float barX, barY;
  int points;
  
  // blocks
  int blockTimer;
  float blockSpawnTime;
  int maxBlocks;
  ArrayList<Block> blocks;
  
  // treats
  int treatTimer;
  float treatSpawnTime;
  int maxTreats;
  ArrayList<Treat> treats;
  
  PImage hand;
  
  
  public Play() {
    pauseBtn = new Button(width*0.9, 30, 35, 35, "||");
    barX = 100;
    barY = 40;
    points = 0;
    cat = new Cat(300, 50, barX, barY);
    // blocks
    blockTimer = millis();
    blockSpawnTime = 10;
    maxBlocks = 10;
    blocks = new ArrayList<Block>();
    // treats
    treatTimer = millis();
   treatSpawnTime = 8;
    maxTreats = 4;
    treats = new ArrayList<Treat>();
    hand = loadImage("hand.png");
  }

  public void display() {
    background(255);
    rectMode(CENTER);
    fill(#A8FF9D);
    rect(width/2, height, width, height/2);

    fill(0);
    
    imageMode(CENTER);
    image(hand, mouseX, mouseY, barX, barY);
    cat.update();
    cat.display();

    // block handling
    handleBlocks();
    
    // treat handling
    handleTreats();
  }

  void handleBlocks() {
    displayBlocks();
    handleBlockCollisions(cat);
  }
  
  void handleTreats() {
    displayTreats();
  }

  void displayBlocks() {
    rectMode(CORNER);
    
    // time handling inspired by
    // https://stackoverflow.com/questions/12417937/create-a-simple-countdown-in-processing
    
    // blocks appear every spawnTime
    int elapsedTime = millis() - blockTimer;
    if (elapsedTime > blockSpawnTime*1000) {
      if (blocks.size() < maxBlocks ) {
        // add block
        blocks.add(new Block(random(30, width-30), random(30, height/3)));
        // spawnTime decreases until it is 2 seconds
        blockSpawnTime = max(blockSpawnTime/3, 2);
      } else {
        // remove block
        blocks.remove(0);
      }
      // reset timer
      blockTimer = millis();
    }

    // display blocks
    for (Block currBlock : blocks) {
      currBlock.display();
    }
  }
  
  void displayTreats() {
    // blocks appear every spawnTime
    int elapsedTime = millis() - treatTimer;
    if (elapsedTime > treatSpawnTime*1000) {
      if (treats.size() < maxTreats ) {
        // add treat
        treats.add(new Treat(random(30, width-30), random(30, height/2)));
        // treatSpawnTime decreases until it is 4 seconds
        treatSpawnTime = max(treatSpawnTime/3, 4);
      } else {
        // remove treat
        treats.remove(0);
      }
      // reset treat timer
      treatTimer = millis();
    }

    // display treats
    for (Treat currTreat : treats) {
      currTreat.display();
    }
  }

  void handleBlockCollisions(Cat currCat) {
    for (Block currBlock : blocks) {
      // vertical block collision with cat, change cat's y direction
      if ( (currCat.x+currCat.diam/2) >= currBlock.x
        && (currCat.x-currCat.diam/2) <= (currBlock.x+currBlock.diam)
        && (currCat.y+currCat.diam/2) >= currBlock.y
        && (currCat.y-currCat.diam/2) <= (currBlock.y+currBlock.diam)) {
        currCat.vy = -currCat.vy;
      }
      // horizontal block collision with cat, change cat's x direction
      if ( (currCat.y+currCat.diam/2) >= currBlock.y
        && (currCat.y-currCat.diam/2) <= (currBlock.y+currBlock.diam)
        && (currCat.x+currCat.diam/2) >= currBlock.x
        && (currCat.x-currCat.diam/2) <= (currBlock.x+currBlock.diam)) {
        currCat.vx = -currCat.vx;
      }
    }
  }
  
  void handleTreatCollisions(Cat currCat) {
    for (Treat currTreat : treats) {
      // vertical block collision with cat, change cat's y direction
      if ( (currCat.x+currCat.diam/2) >= currTreat.x
        && (currCat.x-currCat.diam/2) <= (currTreat.x+currTreat.diam)
        && (currCat.y+currCat.diam/2) >= currTreat.y
        && (currCat.y-currCat.diam/2) <= (currTreat.y+currTreat.diam)) {
        treats.remove(currTreat);
        points++;
      }
      // horizontal block collision with cat, change cat's x direction
      if ( (currCat.y+currCat.diam/2) >= currTreat.y
        && (currCat.y-currCat.diam/2) <= (currTreat.y+currTreat.diam)
        && (currCat.x+currCat.diam/2) >= currTreat.x
        && (currCat.x-currCat.diam/2) <= (currTreat.x+currTreat.diam)) {
        currCat.vx = -currCat.vx;
        treats.remove(currTreat);
        points++;
      }
    }
  }
}
